import Promise from 'bluebird'
import { readFile } from 'fs'
import config from 'config'
import { makeExecutableSchema } from 'graphql-tools'
import title from 'uppercamelcase'
import merge from 'deepmerge'
import resolvers from './resolvers'
import { getPlayerStats } from './smash'

export const schemaFile = config.has('oversmash.schemaFile')
  ? config.get('oversmash.schemaFile') : 'schema.graphql'

const readFileAsync = Promise.promisify(readFile)
const baseSchema = `
# Auto-generated by bin/generate-schema
# DO NOT EDIT MANUALLY, ALL CHANGES WILL BE OVERWRITTEN

type Achievement {
  name: String!
  achieved: Boolean!
}

type PlayerAccountStats {
  competitiveRank: Int
  achievements: [Achievement!]!
  quickplay: GamemodeStats!
  competitive: GamemodeStats!
}

type PlayerAccount {
  level: Int!
  region: String!
  displayName: String!
  platform: String!
  stats: PlayerAccountStats!
  portrait: String!
}

type Player {
  accounts: [PlayerAccount!]!
  account(region: String!, platform: String!): PlayerAccount
}

type Query {
  player(name: String!): Player
}
`

export async function loadSchemaFile () {
  return (await readFileAsync(schemaFile)).toString()
}

export async function loadSchema () {
  return makeExecutableSchema({
    typeDefs: await loadSchemaFile(),
    resolvers
  })
}

// Builds a training set by combining multiple stats payloads for the given accounts
async function loadTrainingSetData (accounts) {
  const mergedSet = await Promise.reduce(accounts, async (data, account) => {
    return merge(data, (await getPlayerStats(account.name, account.region, account.platform)).stats)
  }, {})

  return { ...mergedSet.quickplay, ...mergedSet.competitive }
}

// Returns the GraphQL scalar type (from a limited set) from the given value,
// by inspecting its type
function scalarTypeFromValue (value) {
  if (typeof value === 'number') {
    if (value % 1 === 0) {
      return 'Int'
    }

    return 'Float'
  } else if (typeof value === 'string') {
    return 'String'
  } else {
    throw new Error(`Could not infer scalar type from '${value}'`)
  }
}

export async function generateSchema (trainingAccountsSet) {
  const trainingSet = await loadTrainingSetData(trainingAccountsSet)

  // Iterate through each hero:
  const heroes = Object.keys(trainingSet).map(name => {
    const heroTypeName = title(`${name}Stats`)
    const heroStats = trainingSet[name]

    // Iterate through each stats group for this hero:
    const groups = Object.keys(heroStats).map(group => {
      if (group === 'name') {
        return { type: '' }
      }

      const groupTypeName = `${title(name)}${title(group)}Stats`
      const groupStats = heroStats[group]

      // Finally, walk through each stat name/value to infer its type:
      const statTypes = Object.keys(groupStats).map(stat => {
        const value = groupStats[stat]

        return `${stat}: ${scalarTypeFromValue(value)}!`
      })

      return {
        groupTypeName,
        groupName: group,
        type: `type ${groupTypeName} { ${statTypes.join('\n    ')} }`
      }
    })

    return {
      heroTypeName,
      heroName: name,
      type:
      `
        # == ${name} types ==

        ${groups.map(group => group.type).join('\n')}
        type ${heroTypeName} {
          ${groups.map(group => group.groupName && `${group.groupName}: ${group.groupTypeName}`).join('\n  ')}
        }
      `
    }
  })

  return `
    ${baseSchema}

    # == The following types are auto-generated ==

    union HeroStats = ${heroes.map(hero => hero.heroTypeName).join(' | ')}
    type GamemodeStats {
      ${heroes.map(hero => `${hero.heroName}: ${hero.heroTypeName}`).join('\n')}
    }

    ${heroes.map(hero => hero.type).join('\n')}
  `
}
